"""
1. Написать функцию, которая на вход будет принимать произвольное количество аргументов и возвращать их сумму.
2. В сигнатуре функции объявить 4 обязательных аргумента, но оставить возможность передавать в неё сколько угодно
дополнительных аргументов. Попробуйте вызвать функцию в следующих ситуациях и объясните результат:
   - прокинуть в функцию только 1 аргумент
   - прокинуть аргументы таким образом, чтобы обязательный аргумент был передан одновременно позиционно и по ключу
   - создать кортеж со значениями и распаковать его при вызове функции с помощью *
   - создать словарь со значениями и распаковать его при вызове функции с помощью * и **: что наблюдаете? Почему?
"""


# 1. Написать функцию, которая на вход будет принимать произвольное количество аргументов и возвращать их сумму.
def custom_sum(*args):
    if args:
        result = args[0]
    else:
        return
    for arg in args[1:]:
        result += arg
    return result


# 2. В сигнатуре функции объявить 4 обязательных аргумента, но оставить возможность передавать в неё сколько угодно
# дополнительных аргументов.
def custom_sum_modified(a, b, c, d, *args, **kwargs):
    result = a + b + c + d
    if args:
        for arg in args:
            result += arg
    if kwargs:
        for kwarg in kwargs:
            result += kwargs[kwarg]
    return result


if __name__ == '__main__':
    # Объяснить результат, что будет, если: прокинуть в функцию только 1 аргумент.
    # Объяснение: возникнет исключение типа TypeError в связи с недостаточным кол-вом переданных аргументов (см. тесты)
    custom_sum_modified(1)

    # Объяснить результат, что будет, если: прокинуть аргументы таким образом, чтобы обязательный аргумент
    # был передан одновременно позиционно и по ключу
    # Объяснение: возникнет исключение типа TypeError так как передано несколько значений для одного аргумента 'a'
    custom_sum_modified(1, 2, 3, 4, a=2)

    # Объяснить результат, что будет, если: создать кортеж со значениями и распа-ть его при вызове функции с помощью *
    # Объяснение: весь кортеж будет передан как 1 переменная, а следов-но и сумма из 1 элемента будет явл-ся самим эл-ом
    custom_sum((1, 2, 3, 4))

    # Создать словарь со значениями и распаковать его при вызове функции с помощью * и **: что наблюдаете? Почему?
    args_as_one_dict = {'e': 1, 'f': 2, 'g': 3, 'h': 4, 'i': 5, 'j': 6, 'k': 7}

    # Объяснение: при распаковке с помощью * весь словарь будет передан как 1 перем. и сумма будет равна этому элементу
    custom_sum(args_as_one_dict)

    # Объяснение: при распаковке с помощью ** всё будет работать корректно, т.е. все переданные переменные распакуются
    custom_sum_modified(1, 2, 3, 4, **args_as_one_dict)
